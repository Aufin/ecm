#TITLE: ECM-SPA: A minimal SPA foundation


I've got an application that's turning 20 this
year([2024-01-03 Wed]). It needs a total refactoring. It's a web app.

There may be times when I don't pay attention to it for a while. A
year even. That means minimal dependencies.

And, I'm old school. Keeping things tiny with a foundation, not a
framework, is the goal here.

I want this application to turn 40. Half way there!

* Demo and Documentation

The idea here is that the documentation outlines and implements a demo
which itself is a test of the SPA library itself.

** Index.html

The premise is that the =index.html= takes care of some dependencies
and then loads =index.js=.

#+begin_src html :tangle ./spa/demo/html/index.html
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>ECM-SPA Demo</title>
        <!-- CSS FILES -->
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/uikit@latest/dist/css/uikit.min.css">
        <link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
        <script>
          /*to prevent Firefox FOUC, this should be here*/
          let FF_FOUC_FIX;
        </script>
      </head>
      <body><div id="EcmSPA"> This is where the SPA will be. Loading spinner perhaps</div>
      <script src="https://cdn.jsdelivr.net/npm/uikit@latest/dist/js/uikit.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/uikit@latest/dist/js/uikit-icons.min.js"></script>
      <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
      <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/any-date-parser@1.5.4/dist/browser-bundle.js"></script>
      <script src="index.js"></script>
      </body>
    </html>
#+end_src


What is done is to replace the contents of =#EcmSPA= with =./main.html=.

** =main.html=

#+begin_src html :tangle ./spa/demo/html/main.html
  <div id="demoMain">
   <nav data-ecm-replace="/navbar.html"></nav>
    <div data-ecm-replace="auto-select.html"></div>
    <input data-ecm-date type="date" class="uk-input"/>
    <script>
    </script>
  </div>

#+end_src

** Navbar

#+begin_src html :tangle ./spa/demo/html/navbar.html
     <nav class="uk-navbar-container">
      <div class="uk-container-expand" >
        <div uk-navbar>
          <div class="uk-navbar-left uk-padding uk-padding-remove-right uk-padding-remove-vertical">

            <a class="uk-navbar-item uk-logo" href="#" aria-label="Back to Home">Logo</a>

            <ul class="uk-navbar-nav">
              <li>
                <a href="#">
                  <span class="uk-icon uk-margin-small-right" uk-icon="icon: star"></span>
                  Features
                </a>
              </li>
            </ul>

            <div class="uk-navbar-item">
              <div>Some <a href="#">Link</a></div>
            </div>

            <div class="uk-navbar-item">
              <form action="javascript:void(0)">
                <input class="uk-input uk-form-width-small" type="text" placeholder="Input" aria-label="Input">
                <button class="uk-button uk-button-default">Button</button>
              </form>
            </div>

          </div>

        </div>
      </div>
    </nav>
#+end_src


* Implementation

** An =EcmSPA= object, global =ECM= instance

#+begin_src js :noweb-ref global-ECM
   $(function () {
      globalThis.ECM = new EcmSPA();
  
   $("#EcmSPA").each((_, e) => {
   	ECM.loadElement('/main.html')
  	    .then(ne => { $(e).empty(); $(e).append(ne) })
       });

  });

#+end_src


*** Constructor =EcmSPA=

#+begin_src js :tangle ./spa/js/index.js :comments org
  function EcmSPA () {
    this.router = new EcmRouter()
   return this;
  }

#+end_src

*** Initialize an element

#+begin_src js :tangle ./spa/js/index.js :comments org

  EcmSPA.prototype.initFunctions = {}
  EcmSPA.prototype.initElement = function(el) {
      Object.values(this.initFunctions).forEach(init => {
  	init.call(this, el)
      })
      
      $(el).data('ecm-instance', true)
      return el
  }
#+end_src

*** Load an element

#+begin_src js :tangle ./spa/js/index.js :comments org
  EcmSPA.prototype.loadElement = function(name, use_cache = true){
     return this.router.loadElement(name, use_cache).then(e => {
      // some elements might replace themselves
        const bdy = document.createElement('div');
         bdy.append(e)
  	if (!$(e).data('ecm-instance')) {
  	    this.initElement(e)
  	}
  	return bdy.firstChild
      })
  }
#+end_src

*** Replace an element

#+begin_src js :tangle ./spa/js/index.js :comments org
  EcmSPA.prototype.replaceElement = function(from, to, use_cache = true){
     return this.loadElement(to, use_cache).then(e => {
        from.replaceWith(e)
        return e
      })
  }
#+end_src

#+begin_src js  :tangle ./spa/js/index.js :comments org
  EcmSPA.prototype.initFunctions.ecm_replace = function (el) {
      const init = (e) => { this.replaceElement(e, $(e).data('ecm-replace'))};
      if (el.hasAttribute('data-ecm-replace')) { init(el) }
    
      $(el).find('[data-ecm-replace]').each((_, e) => {  init (e) })
      
  }
#+end_src

** Pages, in single page? The router

#+begin_src js :tangle ./spa/js/index.js :comments org
   function EcmRouter() {
       this.elements = {}
       return this;
   }

   EcmRouter.prototype.loadElement = function(name, use_cache = true) {
       if (use_cache) {
   	const el = this.elements[name]
   	if (el) { return new Promise(r => r(el)); }
       }
       
       return fetch(name)
       	.then(res => res.text()
         	      .then(t => {
       		  const edoc = new DOMParser().parseFromString(t, "text/html"),
   			el = edoc.body.firstChild
       		  this.elements[name] = el
   		  return el
       	      })
   	     )
   }


#+end_src

** =EcmDateTimePicker=: ="date"=. ="time"= and ="datetime-local"=


#+begin_src js :noweb-ref ecm-date-time
  function EcmDateTime(el) {
    if (el.jquery) { el = el[0] };

  return this.init(el);
  }
#+end_src

#+begin_src js :noweb-ref ecm-auto
   EcmDateTime.prototype.elementHtml = `
   <div data-ecm-date-wrapper class="ecm-select uk-select">
    <input type="hidden" data-ecm-select-name>
    <form autocomplete="off">
     <input class='uk-input' type="text" data-ecm-select-text>
     <ul class="ecm-options" data-ecm-options></ul>
    </form>
   </div>`;

  EcmAutoComplete.prototype.makeEmptyElement = function(html = false) {
   const edoc = new DOMParser().parseFromString(html || this.elementHtml, "text/html"),
         child = edoc.body.firstChild
      return child;
  }
#+end_src



*** <input type="date">



** Autocomplete dropdown select thing

https://www.algolia.com/blog/engineering/how-to-implement-autocomplete-with-javascript-on-your-website/
https://stackoverflow.com/questions/30797244/detecting-the-end-of-the-scrollable-drop-down

#+begin_src js :noweb-ref ecm-auto
  EcmSPA.prototype.initFunctions.ecm_auto_complete = (el) => {
      function init (e) { return new EcmAutoComplete(e, true) };
      if (el.hasAttribute('data-ecm-select')) { init(el) }
    
       
      $(el).find('[data-ecm-select]').each((_, e) => {  init (e) })
      
  }
#+end_src

*** Default Static Select

To start off simple we have an HTML select.

#+begin_src html :tangle ./spa/demo/html/auto-select.html
  <div>
  This is testing the <code>data-ecm-select</code> attribute
    <select class="uk-select" data-ecm-select name="examiner-id">
      <option selected></option>
      <option value="1">First Lady</option>
      <option value="2">Second Cousin</option>
      <option value="3">Third Place</option>
      <option value="4">Four on the floor</option>
    </select>
  </div>
    
#+end_src

The idea here is that it becomes an =EcmAutoComplete= without any effort on our side.

#+begin_src js :noweb-ref ecm-auto
  EcmAutoComplete.prototype.selectToObject = (select) => {
    return {
  	name: select.name,
  	options: [... select.options].map(o => {
  	    return {
  		value: o.value,
  		text: o.text
  	    }
  	})
    }
  };
#+end_src

That select turns into our select.

#+begin_src js :noweb-ref ecm-auto
   EcmAutoComplete.prototype.elementHtml = `
   <div data-ecm-select class="ecm-select uk-select">
    <input type="hidden" data-ecm-select-name>
    <form autocomplete="off">
     <input class='uk-input' type="text" data-ecm-select-text>
     <ul class="ecm-options" data-ecm-options></ul>
    </form>
   </div>`;

  EcmAutoComplete.prototype.makeEmptyElement = function(html = false) {
   const edoc = new DOMParser().parseFromString(html || this.elementHtml, "text/html"),
         child = edoc.body.firstChild
      return child;
  }
#+end_src


So just need a way to put them together.

#+begin_src js :noweb-ref ecm-auto
  EcmAutoComplete.prototype.optionsUl = false;
  EcmAutoComplete.prototype.addOptions = function (opts) {
      const ul = this.optionsUl 
      var list = ''
      
      for (i=0; i<opts.length; i++) {
  	list += '<li data-ecm-option'
  	    + ((val = opts[i].value) => {
  	      if (val) {
  		  return '="' + val + '"';
  	      } else  { return '' }
  	  })()
  	    + '><a href="#">'+opts[i].text+'</a></li>'
      }

      ul.innerHTML = ul.innerHTML + list
  }


  	    
  EcmAutoComplete.prototype.makeElement = function (name = '', opts = [], html = false) {
      const el = this.makeEmptyElement(html)
      console.log('el', el)
      $(el).find('[data-ecm-select-name]').each((_, e) => {
  	this.nameInput = e
  	e.setAttribute('name', name)
      });
      $(el).find('[data-ecm-select-text]').each((_, e)  => { this.textInput = e });
      $(el).find('[data-ecm-options]').each((_, e) => {
  	this.optionsUl = e
  	this.addOptions(opts)
      });
      console.log('el', el)
  return el;
  };

  EcmAutoComplete.prototype.makeElementFromSelect = function (sel, html = false) {
   const {name, options} = this.selectToObject(sel)

   return this.makeElement(name, options)
  }
#+end_src

** The css style

#+begin_src js :noweb-ref ecm-auto
    EcmAutoComplete.prototype.elementCss = `
        .ecm-select { width: unset; position:relative; z-index: 9}

       .ecm-select input {
         background: unset;
         height: 30px;
         vertical-align: unset;
       }

       .ecm-options{
         background-clip: padding-box;
         background-color: #fff;
         border: 1px solid #dfe8f1;
         border-top: unset;
         border-radius: 3px;
         box-shadow: 0 1px 7px 2px rgba(135, 158, 171, 0.2);
         display: none;
         list-style: outside none none;
         padding: 0 0 10px;
         position: absolute;
         z-index: 8; 
         float: left;
         list-style: outside none none; max-height:220px; overflow:auto;
         margin:0px;
         left:0px;
         right:0px;
         
       }

       ul.ecm-options li {
         float: none;
         display: block;
         clear: both;
         position: relative;
       }

       ul.ecm-options li a {
         padding: .9em 1em .9em .8em;
         position: relative;
         clear: both;
         cursor: pointer;
         display: block;
         white-space: nowrap;
         text-overflow: ellipsis;
         overflow: hidden;
         color: #4c4c4c;
         text-decoration: none;
         outline: 0;
       }
       ul.ecm-options li a:hover {
       background: none repeat scroll 0 0 #eff4f6;
       cursor: pointer;
       text-decoration: underline;
  	color: #1e87f0;
      }
  `;

  EcmAutoComplete.prototype.appendStyle = function (replace = false) {
      const existing = $(document.head).data('ecm-autocomplete-style')
      if (existing && !replace) { return existing }
      
      const style = document.createElement('style')
      style.append(this.elementCss)
      $(document.head).append(style)
      $(document.head).data('ecm-autocomplete-style', style)
      return style;
  }
   
      
#+end_src


#+begin_src js :tangle ./spa/js/index.js :noweb yes

  function EcmAutoComplete (args, replace = false) {
      const self = this;

      self.appendStyle()

      function isElement(element) {
  	return element instanceof Element || element instanceof HTMLDocument;  
      }
      
      if (isElement(args)) {
          const existing = $(args).data('ecm-autocomplete')
          if (existing) { return existing }
          if (args.tagName.toLowerCase() !== "select") {
             throw new Error("Cannot yet make an autocomplete from a non-select")
           }
  	this.element = this.makeElementFromSelect(args)
          if  (replace) { args.replaceWith(this.element) }
          $(this.element).data('ecm-autocomplete', this);
  	return this
      } ;

      return this.elementPromise(args).then(element => {

    	
    	$(element).on("click",function(event){
    	    const elq = $(element).find('.ecm-options').toggle();
    	});

    	$(element).find('.ecm-options').scroll(function () {
              if ($(this)[0].scrollHeight - $(this).scrollTop() <=  $(this).outerHeight()) {
    		alert("end of scroll");
    		// You can perform as you want

              }
    	});

    	$(element).find("input").each((n,e) => $(e).data("ecm-autocomplete", self))
  	self.target = element;

  	//  alert('asd')

    	return element;
      });
  };


  EcmAutoComplete.prototype.element_cache = false;

  EcmAutoComplete.prototype.default_element_args = {
      location: "/autocomplete.html",
      refresh: false
  };

  EcmAutoComplete.prototype.elementPromise = function (args = {}) {
      const Args = Object.assign({}, this.default_element_args, args),
    	  loc = Args.location,
    	  ref = Args.refresh

      if (this.element_cache && !ref) {
    	return new Promise((r) => r(this.element_cache))
      } else {
    	return fetch(loc)
    	    .then(res => res.text()
      		  .then(t => {
    		      const edoc = new DOMParser().parseFromString(t, "text/html")
    		      this.element_cache = edoc.body.firstChild
                        return this.element_cache
    		  }))
      }
  }

  var search_terms = ['apple', 'apple watch', 'apple macbook', 'apple macbook pro', 'iphone', 'iphone 12'];

  EcmAutoComplete.prototype.autocompleteMatch = function (input) {
      if (input == '') {
  	return [];
      }
      var reg = new RegExp(input)
      return search_terms.filter(function(term) {
  	if (term.match(reg)) {
    	    return term;
  	}
      });
  }

  EcmAutoComplete.prototype.showResults = function (val) {
      resq = $(this.target).find(".ecm-options")
      res = resq[0]
      if (!this.firstHTML) { this.firstHTML = res.innerHTML }
      res.innerHTML = '';

      let list = '';
      let terms = this.autocompleteMatch(val);
      for (i=0; i<terms.length; i++) {
  	list += '<li><a href="javascript:;">' + terms[i] + '</a></li>';
      }
      list ? resq.show() : resq.hide();
      res.innerHTML =  list || this.firstHTML;
  }

  <<ecm-auto>>      

  <<ecm-date-time>>      

  <<global-ECM>>

 #+end_src

 
 #+begin_src html :tangle ./spa/demo/html/autocomplete.html
   <div>
   <div class="ecm-select uk-select">
     <form autocomplete="off">
           <input class='uk-input' type="text" name="q" id="q" onKeyUp="$(this).data('ecm-autocomplete').showResults(this.value)" />
         <ul class="ecm-options">
         </ul>
     </form>
   </div>

   <style>
     .ecm-select { width: unset; position:relative; z-index: 9}

     .ecm-select input {
       background: unset;
       height: 30px;
       vertical-align: unset;
     }

     .ecm-options{
       background-clip: padding-box;
       background-color: #fff;
       border: 1px solid #dfe8f1;
       border-top: unset;
       border-radius: 3px;
       box-shadow: 0 1px 7px 2px rgba(135, 158, 171, 0.2);
       display: none;
       list-style: outside none none;
       padding: 0 0 10px;
       position: absolute;
       z-index: 8; 
       float: left;
       list-style: outside none none; max-height:220px; overflow:auto;
       margin:0px;
       left:0px;
       right:0px;
       
     }

     ul.ecm-options li {
       float: none;
       display: block;
       clear: both;
       position: relative;
     }

     ul.ecm-options li a {
       padding: .9em 1em .9em .8em;
       position: relative;
       clear: both;
       cursor: pointer;
       display: block;
       white-space: nowrap;
       text-overflow: ellipsis;
       overflow: hidden;
       color: #4c4c4c;
       text-decoration: none;
       outline: 0;
     }
     ul.ecm-options li a:hover {
     background: none repeat scroll 0 0 #eff4f6;
     cursor: pointer;
     text-decoration: underline;
	color: #1e87f0;
    }
   </style>
   </div>



#+end_src


** Gerbil Server

#+begin_src scheme
  (reload :std/sxml/print)
  (reload :std/sxml/html/parser)
  (reload :std/html)
  (reload :std/sxml/tal/expander)
  (reload :std/sxml/tal/syntax)
  (reload :std/sxml/tal/toplevel)

  (current-directory "~/src/ecm-spa/spa/demo")
  (def spa-server (start-spa-http-server!))
#+end_src


#+begin_src scheme
  (import :std/net/httpd/mux :std/net/httpd :std/net/uri :std/contract :std/interface)

  (def (fserve name (type "text/html"))
    (lambda (_ res) (http-response-file res `(("Content-type" . ,type)) name)))

  (def (index.html _ res)
    (http-response-file res '(("Content-type" . "text/html"))
  		     "./html/index.html"))

    
  (def spa-mux
    (make-static-http-mux
     (list->hash-table
      `(("index." .,(cut index.html <> <>))))
     (cut index.html <> <>)))

  (using (self spa-mux :- static-http-mux)
    (hash-put! self.t "/index.js" (fserve "../js/index.js" "text/javascript"))
    (hash-put! self.t "/navbar.html" (fserve "./html/navbar.html"))
    (hash-put! self.t "/auto-select.html" (fserve "./html/auto-select.html"))
    (hash-put! self.t "/main.html" (fserve "./html/main.html"))
    (hash-put! self.t "/autocomplete.html" (fserve "./html/autocomplete.html")))

  (def (start-spa-http-server! (address "0.0.0.0:8084"))
    (start-http-server! address mux: spa-mux))
#+end_src

* JavaScript and HTML clients




